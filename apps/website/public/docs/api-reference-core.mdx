# Core Methods

The core methods available on BleakChat instances for managing conversations and handling responses.

## BleakChat Methods

### ask(prompt, options?)

Start a new conversation with the BleakAI backend.

```typescript
ask(prompt: string, options?: {
  context?: any;
}): Promise<ChatResponse>
```

**Parameters:**

- `prompt` - The initial question or prompt to send to the AI
- `options.context` - Optional context object for maintaining conversation state

**Returns:** Promise resolving to a `ChatResponse`

**Example:**

```typescript
const response = await client.ask("Help me plan a vacation to Japan");

if (response.type === "questions") {
  // Handle questions
  console.log("AI needs more information:", response.questions);
} else if (response.type === "answer") {
  // Handle direct answer
  console.log("AI Response:", response.content);
}
```

### answer(answers)

Continue conversation by providing answers to previously asked questions.

```typescript
answer(answers: AnsweredQuestion[]): Promise<ChatResponse>
```

**Parameters:**

- `answers` - Array of answered questions with question IDs and user responses

**Returns:** Promise resolving to a `ChatResponse`

**Example:**

```typescript
const answers = [
  {question_id: "q1", answer: "$2000-5000"},
  {question_id: "q2", answer: "7 days"},
  {question_id: "q3", answer: ["Museums", "Food Tours"]}
];

const response = await client.answer(answers);
```

### finish()

End the conversation and get final response based on current context.

```typescript
finish(): Promise<ChatResponse>
```

**Returns:** Promise resolving to a `ChatResponse`

**Example:**

```typescript
// End conversation and get final result
const finalResponse = await client.finish();

if (finalResponse.type === "answer") {
  console.log("Final result:", finalResponse.content);
}
```

## Core Types

### ChatResponse

Union type representing all possible responses from the BleakAI backend.

```typescript
type ChatResponse =
  | {type: "questions"; questions: InteractiveQuestion[]}
  | {type: "answer"; content: string}
  | {type: "complete"; content: string};
```

### InteractiveQuestion

Represents a question generated by the AI that needs user input.

```typescript
interface InteractiveQuestion {
  question_id: string;
  type: string;
  text: string;
  options?: string[] | null;
  required?: boolean;
}
```

**Properties:**

- `question_id` - Unique identifier for the question
- `type` - Component type (text, radio, multiSelect, slider, etc.)
- `text` - The question text to display to the user
- `options` - Array of options for choice-based questions (null for text input)
- `required` - Whether the question must be answered

### AnsweredQuestion

Represents a user's answer to a question.

```typescript
interface AnsweredQuestion {
  question_id: string;
  answer: string | string[];
}
```

**Properties:**

- `question_id` - The ID of the question being answered
- `answer` - The user's response (string for single values, string array for multi-select)

### BleakElement

Defines the structure of dynamic form elements that can be extended.

```typescript
interface BleakElement {
  type: string;
  text: string;
  options?: string[] | null;
  required?: boolean;
  validation?: ValidationRule[];
}
```

## Error Handling

All methods can throw specific error types:

```typescript
import {ChatError, RateLimitError, AuthenticationError} from "bleakai";

try {
  const response = await client.ask("Hello");
} catch (error) {
  if (error instanceof RateLimitError) {
    console.log(`Rate limited. Retry after: ${error.retryAfter}s`);
  } else if (error instanceof AuthenticationError) {
    console.log("Authentication failed. Check your API keys.");
  } else if (error instanceof ChatError) {
    console.log(`Chat error: ${error.message}`);
  } else {
    console.log("Unexpected error:", error);
  }
}
```

## Advanced Usage

### Conversation State Management

```typescript
class ConversationManager {
  private client: BleakChat;
  private conversationHistory: ChatResponse[] = [];

  constructor(client: BleakChat) {
    this.client = client;
  }

  async startConversation(prompt: string) {
    const response = await this.client.ask(prompt);
    this.conversationHistory.push(response);
    return response;
  }

  async continueConversation(answers: AnsweredQuestion[]) {
    const response = await this.client.answer(answers);
    this.conversationHistory.push(response);
    return response;
  }

  getHistory() {
    return this.conversationHistory;
  }
}
```

### Type-Safe Response Handling

```typescript
const handleResponse = (response: ChatResponse) => {
  switch (response.type) {
    case "questions":
      return renderQuestions(response.questions);
    case "answer":
      return displayAnswer(response.content);
    case "complete":
      return showCompletion(response.content);
    default:
      // TypeScript will ensure this is never reached
      const _exhaustive: never = response;
      throw new Error(`Unhandled response type`);
  }
};
```
